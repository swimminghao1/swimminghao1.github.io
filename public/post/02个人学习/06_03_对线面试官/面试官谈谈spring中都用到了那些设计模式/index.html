<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>面试官“谈谈Spring中都用到了那些设计模式”。 | swimminghao</title><meta name=keywords content="面试,记录"><meta name=description content="面试官:“谈谈Spring中都用到了那些设计模式?”。 JDK 中用到了那些设计模式?Spring 中用到了那些设计模式?这两个问题，在面试中比较常见"><meta name=author content="swimminghao"><link rel=canonical href=https://www.swimminghao.top/post/02%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/06_03_%E5%AF%B9%E7%BA%BF%E9%9D%A2%E8%AF%95%E5%AE%98/%E9%9D%A2%E8%AF%95%E5%AE%98%E8%B0%88%E8%B0%88spring%E4%B8%AD%E9%83%BD%E7%94%A8%E5%88%B0%E4%BA%86%E9%82%A3%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/><meta name=yandex-verification content="73b1a797f62c0e98"><meta name=baidu-site-verification content="code-gnOrbP1RyC"><meta name=baidu_union_verify content="4c552c344295cb984c46ebe74962b067"><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/satouriko/LxgwWenKai_Webfonts@v1.101/dist/LXGWWenKai-Light.css><link crossorigin=anonymous href=/assets/css/stylesheet.min.0a5d9aa21e56d0b7d41b1d4b56af0b911caf526faf5060a8d3717579bf27cb93.css integrity="sha256-Cl2aoh5W0LfUGx1LVq8LkRyvUm+vUGCo03F1eb8ny5M=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.swimminghao.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.swimminghao.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.swimminghao.top/favicon-32x32.png><link rel=apple-touch-icon href=https://www.swimminghao.top/apple-touch-icon.png><link rel=mask-icon href=https://www.swimminghao.top/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.97.0"><link rel=manifest href=/manifest.json><script type=text/javascript>function downloadJSAtOnload(){var e=document.createElement("script");e.src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7296634171837358",document.body.appendChild(e)}window.addEventListener?window.addEventListener("load",downloadJSAtOnload,!1):window.attachEvent?window.attachEvent("onload",downloadJSAtOnload):window.onload=downloadJSAtOnload</script><script async defer data-website-id=3d947a98-2774-46b0-805f-fe2e4877a1d7 src=https://umami.frytea.com/umami.js></script>
<script async src=https://www.swimminghao.top/js/busuanzi.pure.mini.js></script>
<link rel=stylesheet href=/libs/font-awesome-4.7.0/css/font-awesome.min.css><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://www.swimminghao.top/js/mermaid.min.js crossorigin=anonymous></script>
<script>const config={startOnLoad:!0,theme:"forest",themeVariables:{lineColor:"#fafafa"},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))}</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?c49e2f5be5e009382be07455c33b1394",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-136094326-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="面试官“谈谈Spring中都用到了那些设计模式”。"><meta property="og:description" content="面试官:“谈谈Spring中都用到了那些设计模式?”。 JDK 中用到了那些设计模式?Spring 中用到了那些设计模式?这两个问题，在面试中比较常见"><meta property="og:type" content="article"><meta property="og:url" content="https://www.swimminghao.top/post/02%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/06_03_%E5%AF%B9%E7%BA%BF%E9%9D%A2%E8%AF%95%E5%AE%98/%E9%9D%A2%E8%AF%95%E5%AE%98%E8%B0%88%E8%B0%88spring%E4%B8%AD%E9%83%BD%E7%94%A8%E5%88%B0%E4%BA%86%E9%82%A3%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><meta property="og:image" content="https://www.swimminghao.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-02-28T19:57:47+00:00"><meta property="article:modified_time" content="2022-02-28T19:57:47+00:00"><meta property="og:site_name" content="swimminghao"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.swimminghao.top/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="面试官“谈谈Spring中都用到了那些设计模式”。"><meta name=twitter:description content="面试官:“谈谈Spring中都用到了那些设计模式?”。 JDK 中用到了那些设计模式?Spring 中用到了那些设计模式?这两个问题，在面试中比较常见"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.swimminghao.top/post/"},{"@type":"ListItem","position":2,"name":"面试官“谈谈Spring中都用到了那些设计模式”。","item":"https://www.swimminghao.top/post/02%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/06_03_%E5%AF%B9%E7%BA%BF%E9%9D%A2%E8%AF%95%E5%AE%98/%E9%9D%A2%E8%AF%95%E5%AE%98%E8%B0%88%E8%B0%88spring%E4%B8%AD%E9%83%BD%E7%94%A8%E5%88%B0%E4%BA%86%E9%82%A3%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"面试官“谈谈Spring中都用到了那些设计模式”。","name":"面试官“谈谈Spring中都用到了那些设计模式”。","description":"面试官:“谈谈Spring中都用到了那些设计模式?”。 JDK 中用到了那些设计模式?Spring 中用到了那些设计模式?这两个问题，在面试中比较常见","keywords":["面试","记录"],"articleBody":"面试官:“谈谈Spring中都用到了那些设计模式?”。 JDK 中用到了那些设计模式?Spring 中用到了那些设计模式?这两个问题，在面试中比较常见。我在网上搜索了一下关于 Spring 中设计模式的讲解几乎都是千篇一律，而且大部分都年代久远。所以，花了几天时间自己总结了一下，由于我的个人能力有限，文中如有任何错误各位都可以指出。另外，文章篇幅有限，对于设计模式以及一些源码的解读我只是一笔带过，这篇文章的主要目的是回顾一下 Spring 中的常见的设计模式。\nDesign Patterns(设计模式) 表示面向对象软件开发中最好的计算机编程实践。 Spring 框架中广泛使用了不同类型的设计模式，下面我们来看看到底有哪些设计模式?\n控制反转(IoC)和依赖注入(DI) IoC(Inversion of Control,控制翻转) 是Spring 中一个非常非常重要的概念，它不是什么技术，而是一种解耦的设计思想。它的主要目的是借助于“第三方”(Spring 中的 IOC 容器) 实现具有依赖关系的对象之间的解耦(IOC容易管理对象，你只管使用即可)，从而降低代码之间的耦合度。IOC 是一个原则，而不是一个模式，以下模式（但不限于）实现了IoC原则。\nioc-patterns Spring IOC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。 IOC 容器负责创建对象，将对象连接在一起，配置这些对象，并从创建中处理这些对象的整个生命周期，直到它们被完全销毁。\n在实际项目中一个 Service 类如果有几百甚至上千个类作为它的底层，我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IOC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。关于Spring IOC 的理解，推荐看这一下知乎的一个回答：https://www.zhihu.com/question/23277575/answer/169698662 ，非常不错。\n控制翻转怎么理解呢? 举个例子：“对象a 依赖了对象 b，当对象 a 需要使用 对象 b的时候必须自己去创建。但是当系统引入了 IOC 容器后， 对象a 和对象 b 之前就失去了直接的联系。这个时候，当对象 a 需要使用 对象 b的时候， 我们可以指定 IOC 容器去创建一个对象b注入到对象 a 中”。 对象 a 获得依赖对象 b 的过程,由主动行为变为了被动行为，控制权翻转，这就是控制反转名字的由来。\nDI(Dependecy Inject,依赖注入)是实现控制反转的一种设计模式，依赖注入就是将实例变量传入到一个对象中去。\n工厂设计模式 Spring使用工厂模式可以通过 BeanFactory 或 ApplicationContext 创建 bean 对象。\n两者对比：\n BeanFactory ：延迟注入(使用到某个 bean 的时候才会注入),相比于BeanFactory来说会占用更少的内存，程序启动速度更快。 ApplicationContext ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。BeanFactory 仅提供了最基本的依赖注入支持，ApplicationContext 扩展了 BeanFactory ,除了有BeanFactory的功能还有额外更多功能，所以一般开发人员使用ApplicationContext会更多。  ApplicationContext的三个实现类：\n ClassPathXmlApplication：把上下文文件当成类路径资源。 FileSystemXmlApplication：从文件系统中的 XML 文件载入上下文定义信息。 XmlWebApplicationContext：从Web系统中的XML文件载入上下文定义信息。  Example:\nimport org.springframework.context.ApplicationContext; import org.springframework.context.support.FileSystemXmlApplicationContext;  public class App {  public static void main(String[] args) {  ApplicationContext context = new FileSystemXmlApplicationContext(  \"C:/work/IOC Containers/springframework.applicationcontext/src/main/resources/bean-factory-config.xml\");   HelloApplicationContext obj = (HelloApplicationContext) context.getBean(\"helloApplicationContext\");  obj.getMsg();  } } 单例设计模式 在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。\n使用单例模式的好处:\n 对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销； 由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。  Spring 中 bean 的默认作用域就是 singleton(单例)的。 除了 singleton 作用域，Spring 中 bean 还有下面几种作用域：\n prototype : 每次请求都会创建一个新的 bean 实例。 request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。 session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。 global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话  Spring 实现单例的方式：\n xml:`` 注解：@Scope(value = \"singleton\")  Spring 通过 ConcurrentHashMap 实现单例注册表的特殊方式实现单例模式。Spring 实现单例的核心代码如下：\n// 通过 ConcurrentHashMap（线程安全） 实现单例注册表 private final MapString, Object singletonObjects = new ConcurrentHashMapString, Object(64);  public Object getSingleton(String beanName, ObjectFactory singletonFactory) {  Assert.notNull(beanName, \"'beanName' must not be null\");  synchronized (this.singletonObjects) {  // 检查缓存中是否存在实例  Object singletonObject = this.singletonObjects.get(beanName);  if (singletonObject == null) {  //...省略了很多代码  try {  singletonObject = singletonFactory.getObject();  }  //...省略了很多代码  // 如果实例对象在不存在，我们注册到单例注册表中。  addSingleton(beanName, singletonObject);  }  return (singletonObject != NULL_OBJECT ? singletonObject : null);  }  }  //将对象添加到单例注册表  protected void addSingleton(String beanName, Object singletonObject) {  synchronized (this.singletonObjects) {  this.singletonObjects.put(beanName, (singletonObject != null ? singletonObject : NULL_OBJECT));   }  } } 代理设计模式 代理模式在 AOP 中的应用 AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。\nSpring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用Cglib ，这时候Spring AOP会使用 Cglib 生成一个被代理对象的子类来作为代理，如下图所示：\nSpringAOPProcess 当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。\n使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。\nSpring AOP 和 AspectJ AOP 有什么区别? Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。\nSpring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，\n如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。\n模板方法 模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。\n模板方法UML图 public abstract class Template {  //这是我们的模板方法  public final void TemplateMethod(){  PrimitiveOperation1();  PrimitiveOperation2();  PrimitiveOperation3();  }   protected void PrimitiveOperation1(){  //当前类实现  }   //被子类实现的方法  protected abstract void PrimitiveOperation2();  protected abstract void PrimitiveOperation3();  } public class TemplateImpl extends Template {   @Override  public void PrimitiveOperation2() {  //当前类实现  }   @Override  public void PrimitiveOperation3() {  //当前类实现  } } Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。\n观察者模式 观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring 事件驱动模型就是观察者模式很经典的一个应用。Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。\nSpring 事件驱动模型中的三种角色 事件角色 ApplicationEvent (org.springframework.context包下)充当事件的角色,这是一个抽象类，它继承了java.util.EventObject并实现了 java.io.Serializable接口。\nSpring 中默认存在以下事件，他们都是对 ApplicationContextEvent 的实现(继承自ApplicationContextEvent)：\n ContextStartedEvent：ApplicationContext 启动后触发的事件; ContextStoppedEvent：ApplicationContext 停止后触发的事件; ContextRefreshedEvent：ApplicationContext 初始化或刷新完成后触发的事件; ContextClosedEvent：ApplicationContext 关闭后触发的事件。  ApplicationEvent-Subclass 事件监听者角色 ApplicationListener 充当了事件监听者角色，它是一个接口，里面只定义了一个 onApplicationEvent（）方法来处理ApplicationEvent。ApplicationListener接口类源码如下，可以看出接口定义看出接口中的事件只要实现了 ApplicationEvent就可以了。所以，在 Spring中我们只要实现 ApplicationListener 接口实现 onApplicationEvent() 方法即可完成监听事件\npackage org.springframework.context; import java.util.EventListener; @FunctionalInterface public interface ApplicationListenerE extends ApplicationEvent extends EventListener {  void onApplicationEvent(E var1); } 事件发布者角色 ApplicationEventPublisher 充当了事件的发布者，它也是一个接口。\n@FunctionalInterface public interface ApplicationEventPublisher {  default void publishEvent(ApplicationEvent event) {  this.publishEvent((Object)event);  }   void publishEvent(Object var1); } ApplicationEventPublisher 接口的publishEvent（）这个方法在AbstractApplicationContext类中被实现，阅读这个方法的实现，你会发现实际上事件真正是通过ApplicationEventMulticaster来广播出去的。具体内容过多，就不在这里分析了，后面可能会单独写一篇文章提到。\nSpring 的事件流程总结  定义一个事件: 实现一个继承自 ApplicationEvent，并且写相应的构造函数； 定义一个事件监听者：实现 ApplicationListener 接口，重写 onApplicationEvent() 方法； 使用事件发布者发布消息: 可以通过 ApplicationEventPublisher 的 publishEvent() 方法发布消息。  Example:\n// 定义一个事件,继承自ApplicationEvent并且写相应的构造函数 public class DemoEvent extends ApplicationEvent{  private static final long serialVersionUID = 1L;   private String message;   public DemoEvent(Object source,String message){  super(source);  this.message = message;  }   public String getMessage() {  return message;  }   // 定义一个事件监听者,实现ApplicationListener接口，重写 onApplicationEvent() 方法； @Component public class DemoListener implements ApplicationListenerDemoEvent{   //使用onApplicationEvent接收消息  @Override  public void onApplicationEvent(DemoEvent event) {  String msg = event.getMessage();  System.out.println(\"接收到的信息是：\"+msg);  }  } // 发布事件，可以通过ApplicationEventPublisher 的 publishEvent() 方法发布消息。 @Component public class DemoPublisher {   @Autowired  ApplicationContext applicationContext;   public void publish(String message){  //发布事件  applicationContext.publishEvent(new DemoEvent(this, message));  } } 当调用 DemoPublisher 的 publish() 方法的时候，比如 demoPublisher.publish(\"你好\") ，控制台就会打印出:接收到的信息是：你好 。\n适配器模式 适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。\nspring AOP中的适配器模式 我们知道 Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是AdvisorAdapter 。Advice 常用的类型有：BeforeAdvice（目标方法调用前,前置通知）、AfterAdvice（目标方法调用后,后置通知）、AfterReturningAdvice(目标方法执行结束后，return之前)等等。每个类型Advice（通知）都有对应的拦截器:MethodBeforeAdviceInterceptor、AfterReturningAdviceAdapter、AfterReturningAdviceInterceptor。Spring预定义的通知要通过对应的适配器，适配成 MethodInterceptor接口(方法拦截器)类型的对象（如：MethodBeforeAdviceInterceptor 负责适配 MethodBeforeAdvice）。\nspring MVC中的适配器模式 在Spring MVC中，DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由HandlerAdapter 适配器处理。HandlerAdapter 作为期望接口，具体的适配器实现类用于对目标类进行适配，Controller 作为需要适配的类。\n为什么要在 Spring MVC 中使用适配器模式？ Spring MVC 中的 Controller 种类众多，不同类型的 Controller 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，DispatcherServlet 直接获取对应类型的 Controller，需要的自行来判断，像下面这段代码一样：\nif(mappedHandler.getHandler() instanceof MultiActionController){  ((MultiActionController)mappedHandler.getHandler()).xxx }else if(mappedHandler.getHandler() instanceof XXX){  ... }else if(...){  ... } 假如我们再增加一个 Controller类型就要在上面代码中再加入一行 判断语句，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。\n装饰者模式 装饰者模式可以动态地给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。简单点儿说就是当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面。其实在 JDK 中就有很多地方用到了装饰者模式，比如 InputStream家族，InputStream 类下有 FileInputStream (读取文件)、BufferedInputStream (增加缓存,使读取文件速度大大提升)等子类都在不修改InputStream 代码的情况下扩展了它的功能。\n 装饰者模式示意图  Spring 中配置 DataSource 的时候，DataSource 可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？这个时候就要用到装饰者模式(这一点我自己还没太理解具体原理)。Spring 中用到的包装器模式在类名上含有 Wrapper或者 Decorator。这些类基本上都是动态地给一个对象添加一些额外的职责\n总结 Spring 框架中用到了哪些设计模式：\n 工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。 代理设计模式 : Spring AOP 功能的实现。 单例设计模式 : Spring 中的 Bean 默认都是单例的。 模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。 包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。 观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。 适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。 ……  参考  《Spring技术内幕》 https://blog.eduonix.com/java-programming-2/learn-design-patterns-used-spring-framework/ http://blog.yeamin.top/2018/03/27/单例模式-Spring单例实现原理分析/ https://www.tutorialsteacher.com/ioc/inversion-of-control https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/observer.html https://juejin.im/post/5a8eb261f265da4e9e307230 https://juejin.im/post/5ba28986f265da0abc2b6084  ","wordCount":"6281","inLanguage":"zh","datePublished":"2022-02-28T19:57:47Z","dateModified":"2022-02-28T19:57:47Z","author":{"@type":"Person","name":"swimminghao"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.swimminghao.top/post/02%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/06_03_%E5%AF%B9%E7%BA%BF%E9%9D%A2%E8%AF%95%E5%AE%98/%E9%9D%A2%E8%AF%95%E5%AE%98%E8%B0%88%E8%B0%88spring%E4%B8%AD%E9%83%BD%E7%94%A8%E5%88%B0%E4%BA%86%E9%82%A3%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},"publisher":{"@type":"Organization","name":"swimminghao","logo":{"@type":"ImageObject","url":"https://www.swimminghao.top/favicon.ico"}}}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.swimminghao.top/ accesskey=h title="🍀 swimminghao (Alt + H)">🍀 swimminghao</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.swimminghao.top/categories/ title="🗂 归类"><span>🗂 归类</span></a></li><li><a href=https://www.swimminghao.top/tags/ title="🏷️ 标签"><span>🏷️ 标签</span></a></li><li><a href=https://www.swimminghao.top/archives/ title="⏱️ 时间轴"><span>⏱️ 时间轴</span></a></li><li><a href=https://www.swimminghao.top/search/ title="🔍 索引 (Alt + /)" accesskey=/><span>🔍 索引</span></a></li><li><a href=https://www.swimminghao.top/friends title="🧑‍🤝‍🧑 友链"><span>🧑‍🤝‍🧑 友链</span></a></li><li><a href=https://www.travellings.cn/go.html title=🚇><span>🚇</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.swimminghao.top/>主页</a>&nbsp;»&nbsp;<a href=https://www.swimminghao.top/post/>Posts</a></div><h1 class=post-title><a href=https://www.swimminghao.top/post/02%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/06_03_%E5%AF%B9%E7%BA%BF%E9%9D%A2%E8%AF%95%E5%AE%98/%E9%9D%A2%E8%AF%95%E5%AE%98%E8%B0%88%E8%B0%88spring%E4%B8%AD%E9%83%BD%E7%94%A8%E5%88%B0%E4%BA%86%E9%82%A3%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>面试官“谈谈Spring中都用到了那些设计模式”。</a></h1><div class=post-meta>February 28, 2022&nbsp;·&nbsp;13 分钟&nbsp;·&nbsp;6281 字&nbsp;·&nbsp;swimminghao&nbsp;|&nbsp;<a href=https://github.com/songtianlun/songtianlun.github.io/edit/main/content/post/02%e4%b8%aa%e4%ba%ba%e5%ad%a6%e4%b9%a0/06_03_%e5%af%b9%e7%ba%bf%e9%9d%a2%e8%af%95%e5%ae%98/%e9%9d%a2%e8%af%95%e5%ae%98%e2%80%9c%e8%b0%88%e8%b0%88Spring%e4%b8%ad%e9%83%bd%e7%94%a8%e5%88%b0%e4%ba%86%e9%82%a3%e4%ba%9b%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e2%80%9d%e3%80%82.md rel="noopener noreferrer" target=_blank>PR</a>
<span>| <span class=waline-pageview-count data-path=/post/02%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/06_03_%E5%AF%B9%E7%BA%BF%E9%9D%A2%E8%AF%95%E5%AE%98/%E9%9D%A2%E8%AF%95%E5%AE%98%E8%B0%88%E8%B0%88spring%E4%B8%AD%E9%83%BD%E7%94%A8%E5%88%B0%E4%BA%86%E9%82%A3%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/><i class="fa fa-spinner fa-spin"></i></span> Hits</span></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e9%9d%a2%e8%af%95%e5%ae%98%e8%b0%88%e8%b0%88spring%e4%b8%ad%e9%83%bd%e7%94%a8%e5%88%b0%e4%ba%86%e9%82%a3%e4%ba%9b%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f aria-label=面试官:“谈谈Spring中都用到了那些设计模式?”。>面试官:“谈谈Spring中都用到了那些设计模式?”。</a><ul><li><a href=#%e6%8e%a7%e5%88%b6%e5%8f%8d%e8%bd%acioc%e5%92%8c%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5di aria-label=控制反转(IoC)和依赖注入(DI)>控制反转(IoC)和依赖注入(DI)</a></li><li><a href=#%e5%b7%a5%e5%8e%82%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f aria-label=工厂设计模式>工厂设计模式</a></li><li><a href=#%e5%8d%95%e4%be%8b%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f aria-label=单例设计模式>单例设计模式</a></li><li><a href=#%e4%bb%a3%e7%90%86%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f aria-label=代理设计模式>代理设计模式</a><ul><li><a href=#%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8f%e5%9c%a8-aop-%e4%b8%ad%e7%9a%84%e5%ba%94%e7%94%a8 aria-label="代理模式在 AOP 中的应用">代理模式在 AOP 中的应用</a></li><li><a href=#spring-aop-%e5%92%8c-aspectj-aop-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab aria-label="Spring AOP 和 AspectJ AOP 有什么区别?">Spring AOP 和 AspectJ AOP 有什么区别?</a></li></ul></li><li><a href=#%e6%a8%a1%e6%9d%bf%e6%96%b9%e6%b3%95 aria-label=模板方法>模板方法</a></li><li><a href=#%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8f aria-label=观察者模式>观察者模式</a><ul><li><a href=#spring-%e4%ba%8b%e4%bb%b6%e9%a9%b1%e5%8a%a8%e6%a8%a1%e5%9e%8b%e4%b8%ad%e7%9a%84%e4%b8%89%e7%a7%8d%e8%a7%92%e8%89%b2 aria-label="Spring 事件驱动模型中的三种角色">Spring 事件驱动模型中的三种角色</a><ul><li><a href=#%e4%ba%8b%e4%bb%b6%e8%a7%92%e8%89%b2 aria-label=事件角色>事件角色</a></li><li><a href=#%e4%ba%8b%e4%bb%b6%e7%9b%91%e5%90%ac%e8%80%85%e8%a7%92%e8%89%b2 aria-label=事件监听者角色>事件监听者角色</a></li><li><a href=#%e4%ba%8b%e4%bb%b6%e5%8f%91%e5%b8%83%e8%80%85%e8%a7%92%e8%89%b2 aria-label=事件发布者角色>事件发布者角色</a></li></ul></li><li><a href=#spring-%e7%9a%84%e4%ba%8b%e4%bb%b6%e6%b5%81%e7%a8%8b%e6%80%bb%e7%bb%93 aria-label="Spring 的事件流程总结">Spring 的事件流程总结</a></li></ul></li><li><a href=#%e9%80%82%e9%85%8d%e5%99%a8%e6%a8%a1%e5%bc%8f aria-label=适配器模式>适配器模式</a><ul><li><a href=#spring-aop%e4%b8%ad%e7%9a%84%e9%80%82%e9%85%8d%e5%99%a8%e6%a8%a1%e5%bc%8f aria-label="spring AOP中的适配器模式">spring AOP中的适配器模式</a></li><li><a href=#spring-mvc%e4%b8%ad%e7%9a%84%e9%80%82%e9%85%8d%e5%99%a8%e6%a8%a1%e5%bc%8f aria-label="spring MVC中的适配器模式">spring MVC中的适配器模式</a></li></ul></li><li><a href=#%e8%a3%85%e9%a5%b0%e8%80%85%e6%a8%a1%e5%bc%8f aria-label=装饰者模式>装饰者模式</a></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考>参考</a></li></ul></li></ul></div><div><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-7296634171837358 data-ad-slot=9161921641 data-ad-format=auto data-full-width-responsive=true></ins></div><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></details></div><div class=post-content><blockquote style=margin-top:8px><p style=text-align:center;text-indent:0><a href=https://www.swimminghao.top/post/02%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/06_03_%E5%AF%B9%E7%BA%BF%E9%9D%A2%E8%AF%95%E5%AE%98/%E9%9D%A2%E8%AF%95%E5%AE%98%E8%B0%88%E8%B0%88spring%E4%B8%AD%E9%83%BD%E7%94%A8%E5%88%B0%E4%BA%86%E9%82%A3%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>本文</a>
首发于
<a href=https://www.swimminghao.top/>🍀 永浩</a>，
<a href=/disclaimer/>转载</a> 请注明
<a href=https://www.swimminghao.top/post/02%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/06_03_%E5%AF%B9%E7%BA%BF%E9%9D%A2%E8%AF%95%E5%AE%98/%E9%9D%A2%E8%AF%95%E5%AE%98%E8%B0%88%E8%B0%88spring%E4%B8%AD%E9%83%BD%E7%94%A8%E5%88%B0%E4%BA%86%E9%82%A3%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>来源</a>。</p></blockquote><h1 id=面试官谈谈spring中都用到了那些设计模式>面试官:“谈谈Spring中都用到了那些设计模式?”。<a hidden class=anchor aria-hidden=true href=#面试官谈谈spring中都用到了那些设计模式>#</a></h1><p>JDK 中用到了那些设计模式?Spring 中用到了那些设计模式?这两个问题，在面试中比较常见。我在网上搜索了一下关于 Spring 中设计模式的讲解几乎都是千篇一律，而且大部分都年代久远。所以，花了几天时间自己总结了一下，由于我的个人能力有限，文中如有任何错误各位都可以指出。另外，文章篇幅有限，对于设计模式以及一些源码的解读我只是一笔带过，这篇文章的主要目的是回顾一下 Spring 中的常见的设计模式。</p><p>Design Patterns(设计模式) 表示面向对象软件开发中最好的计算机编程实践。 Spring 框架中广泛使用了不同类型的设计模式，下面我们来看看到底有哪些设计模式?</p><h2 id=控制反转ioc和依赖注入di>控制反转(IoC)和依赖注入(DI)<a hidden class=anchor aria-hidden=true href=#控制反转ioc和依赖注入di>#</a></h2><p><strong>IoC(Inversion of Control,控制翻转)</strong> 是Spring 中一个非常非常重要的概念，它不是什么技术，而是一种解耦的设计思想。它的主要目的是借助于“第三方”(Spring 中的 IOC 容器) 实现具有依赖关系的对象之间的解耦(IOC容易管理对象，你只管使用即可)，从而降低代码之间的耦合度。<strong>IOC 是一个原则，而不是一个模式，以下模式（但不限于）实现了IoC原则。</strong></p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TwBuibJ4N5OTyAvJibFj8b7zhiaTcnFwmnfLqQQWwlWv2uNMZyiabexkUSuW24WAWAuL6cvzguu8JyYzw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=图片></p><center>ioc-patterns</center><p><strong>Spring IOC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong> IOC 容器负责创建对象，将对象连接在一起，配置这些对象，并从创建中处理这些对象的整个生命周期，直到它们被完全销毁。</p><p>在实际项目中一个 Service 类如果有几百甚至上千个类作为它的底层，我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IOC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。关于Spring IOC 的理解，推荐看这一下知乎的一个回答：https://www.zhihu.com/question/23277575/answer/169698662 ，非常不错。</p><p><strong>控制翻转怎么理解呢?</strong> 举个例子：&ldquo;对象a 依赖了对象 b，当对象 a 需要使用 对象 b的时候必须自己去创建。但是当系统引入了 IOC 容器后， 对象a 和对象 b 之前就失去了直接的联系。这个时候，当对象 a 需要使用 对象 b的时候， 我们可以指定 IOC 容器去创建一个对象b注入到对象 a 中&rdquo;。 对象 a 获得依赖对象 b 的过程,由主动行为变为了被动行为，控制权翻转，这就是控制反转名字的由来。</p><p><strong>DI(Dependecy Inject,依赖注入)是实现控制反转的一种设计模式，依赖注入就是将实例变量传入到一个对象中去。</strong></p><h2 id=工厂设计模式>工厂设计模式<a hidden class=anchor aria-hidden=true href=#工厂设计模式>#</a></h2><p>Spring使用工厂模式可以通过 <code>BeanFactory</code> 或 <code>ApplicationContext</code> 创建 bean 对象。</p><p><strong>两者对比：</strong></p><ul><li><code>BeanFactory</code> ：延迟注入(使用到某个 bean 的时候才会注入),相比于<code>BeanFactory</code>来说会占用更少的内存，程序启动速度更快。</li><li><code>ApplicationContext</code> ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。<code>BeanFactory</code> 仅提供了最基本的依赖注入支持，<code>ApplicationContext</code> 扩展了 <code>BeanFactory</code> ,除了有<code>BeanFactory</code>的功能还有额外更多功能，所以一般开发人员使用<code>ApplicationContext</code>会更多。</li></ul><p>ApplicationContext的三个实现类：</p><ol><li><code>ClassPathXmlApplication</code>：把上下文文件当成类路径资源。</li><li><code>FileSystemXmlApplication</code>：从文件系统中的 XML 文件载入上下文定义信息。</li><li><code>XmlWebApplicationContext</code>：从Web系统中的XML文件载入上下文定义信息。</li></ol><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> org.springframework.context.ApplicationContext<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> org.springframework.context.support.FileSystemXmlApplicationContext<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>App</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        ApplicationContext context <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FileSystemXmlApplicationContext<span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;C:/work/IOC Containers/springframework.applicationcontext/src/main/resources/bean-factory-config.xml&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        HelloApplicationContext obj <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>HelloApplicationContext<span style=color:#f92672>)</span> context<span style=color:#f92672>.</span><span style=color:#a6e22e>getBean</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;helloApplicationContext&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        obj<span style=color:#f92672>.</span><span style=color:#a6e22e>getMsg</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=单例设计模式>单例设计模式<a hidden class=anchor aria-hidden=true href=#单例设计模式>#</a></h2><p>在我们的系统中，有一些对象其实我们只需要一个，比如说：线程池、缓存、对话框、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象。事实上，这一类对象只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果。</p><p><strong>使用单例模式的好处:</strong></p><ul><li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li><li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li></ul><p><strong>Spring 中 bean 的默认作用域就是 singleton(单例)的。</strong> 除了 singleton 作用域，Spring 中 bean 还有下面几种作用域：</p><ul><li>prototype : 每次请求都会创建一个新的 bean 实例。</li><li>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</li><li>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</li><li>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li></ul><p><strong>Spring 实现单例的方式：</strong></p><ul><li>xml:<bean id=userService class=top.snailclimb.UserService scope=singleton>``</li><li>注解：<code>@Scope(value = "singleton")</code></li></ul><p>Spring 通过 <code>ConcurrentHashMap</code> 实现单例注册表的特殊方式实现单例模式。Spring 实现单例的核心代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 通过 ConcurrentHashMap（线程安全） 实现单例注册表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Map<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>,</span> Object<span style=color:#f92672>&gt;</span> singletonObjects <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ConcurrentHashMap<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>,</span> Object<span style=color:#f92672>&gt;(</span>64<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> Object <span style=color:#a6e22e>getSingleton</span><span style=color:#f92672>(</span>String beanName<span style=color:#f92672>,</span> ObjectFactory<span style=color:#f92672>&lt;?&gt;</span> singletonFactory<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        Assert<span style=color:#f92672>.</span><span style=color:#a6e22e>notNull</span><span style=color:#f92672>(</span>beanName<span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;&#39;beanName&#39; must not be null&#34;</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>synchronized</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>singletonObjects</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 检查缓存中是否存在实例  
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            Object singletonObject <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>singletonObjects</span><span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>(</span>beanName<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>singletonObject <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>//...省略了很多代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                    singletonObject <span style=color:#f92672>=</span> singletonFactory<span style=color:#f92672>.</span><span style=color:#a6e22e>getObject</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>//...省略了很多代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// 如果实例对象在不存在，我们注册到单例注册表中。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                addSingleton<span style=color:#f92672>(</span>beanName<span style=color:#f92672>,</span> singletonObject<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#f92672>(</span>singletonObject <span style=color:#f92672>!=</span> NULL_OBJECT <span style=color:#f92672>?</span> singletonObject <span style=color:#f92672>:</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//将对象添加到单例注册表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>addSingleton</span><span style=color:#f92672>(</span>String beanName<span style=color:#f92672>,</span> Object singletonObject<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>synchronized</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>singletonObjects</span><span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>singletonObjects</span><span style=color:#f92672>.</span><span style=color:#a6e22e>put</span><span style=color:#f92672>(</span>beanName<span style=color:#f92672>,</span> <span style=color:#f92672>(</span>singletonObject <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> singletonObject <span style=color:#f92672>:</span> NULL_OBJECT<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=代理设计模式>代理设计模式<a hidden class=anchor aria-hidden=true href=#代理设计模式>#</a></h2><h3 id=代理模式在-aop-中的应用>代理模式在 AOP 中的应用<a hidden class=anchor aria-hidden=true href=#代理模式在-aop-中的应用>#</a></h3><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p><strong>Spring AOP 就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/16qDep_20210809142649.png alt=图片></p><center>SpringAOPProcess</center><p>当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p><p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p><h3 id=spring-aop-和-aspectj-aop-有什么区别>Spring AOP 和 AspectJ AOP 有什么区别?<a hidden class=anchor aria-hidden=true href=#spring-aop-和-aspectj-aop-有什么区别>#</a></h3><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p><h2 id=模板方法>模板方法<a hidden class=anchor aria-hidden=true href=#模板方法>#</a></h2><p>模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/7MhBrj_20210809142855.png alt=图片></p><center>模板方法UML图</center><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Template</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//这是我们的模板方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>TemplateMethod</span><span style=color:#f92672>(){</span>
</span></span><span style=display:flex><span>        PrimitiveOperation1<span style=color:#f92672>();</span>  
</span></span><span style=display:flex><span>        PrimitiveOperation2<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        PrimitiveOperation3<span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>void</span>  <span style=color:#a6e22e>PrimitiveOperation1</span><span style=color:#f92672>(){</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//当前类实现
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//被子类实现的方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>PrimitiveOperation2</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>PrimitiveOperation3</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TemplateImpl</span> <span style=color:#66d9ef>extends</span> Template <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>PrimitiveOperation2</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//当前类实现
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>PrimitiveOperation3</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//当前类实现
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。一般情况下，我们都是使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用Callback 模式与模板方法模式配合，既达到了代码复用的效果，同时增加了灵活性。</p><h2 id=观察者模式>观察者模式<a hidden class=anchor aria-hidden=true href=#观察者模式>#</a></h2><p>观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应。Spring 事件驱动模型就是观察者模式很经典的一个应用。Spring 事件驱动模型非常有用，在很多场景都可以解耦我们的代码。比如我们每次添加商品的时候都需要重新更新商品索引，这个时候就可以利用观察者模式来解决这个问题。</p><h3 id=spring-事件驱动模型中的三种角色>Spring 事件驱动模型中的三种角色<a hidden class=anchor aria-hidden=true href=#spring-事件驱动模型中的三种角色>#</a></h3><h4 id=事件角色>事件角色<a hidden class=anchor aria-hidden=true href=#事件角色>#</a></h4><p><code>ApplicationEvent</code> (<code>org.springframework.context</code>包下)充当事件的角色,这是一个抽象类，它继承了<code>java.util.EventObject</code>并实现了 <code>java.io.Serializable</code>接口。</p><p>Spring 中默认存在以下事件，他们都是对 <code>ApplicationContextEvent</code> 的实现(继承自<code>ApplicationContextEvent</code>)：</p><ul><li><code>ContextStartedEvent</code>：<code>ApplicationContext</code> 启动后触发的事件;</li><li><code>ContextStoppedEvent</code>：<code>ApplicationContext</code> 停止后触发的事件;</li><li><code>ContextRefreshedEvent</code>：<code>ApplicationContext</code> 初始化或刷新完成后触发的事件;</li><li><code>ContextClosedEvent</code>：<code>ApplicationContext</code> 关闭后触发的事件。</li></ul><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/tKwbDY_20210809143054.png alt=图片></p><center>ApplicationEvent-Subclass</center><h4 id=事件监听者角色>事件监听者角色<a hidden class=anchor aria-hidden=true href=#事件监听者角色>#</a></h4><p><code>ApplicationListener</code> 充当了事件监听者角色，它是一个接口，里面只定义了一个 <code>onApplicationEvent（）</code>方法来处理<code>ApplicationEvent</code>。<code>ApplicationListener</code>接口类源码如下，可以看出接口定义看出接口中的事件只要实现了 <code>ApplicationEvent</code>就可以了。所以，在 Spring中我们只要实现 <code>ApplicationListener</code> 接口实现 <code>onApplicationEvent()</code> 方法即可完成监听事件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> org.springframework.context<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.EventListener<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@FunctionalInterface</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ApplicationListener</span><span style=color:#f92672>&lt;</span>E <span style=color:#66d9ef>extends</span> ApplicationEvent<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>extends</span> EventListener <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onApplicationEvent</span><span style=color:#f92672>(</span>E var1<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h4 id=事件发布者角色>事件发布者角色<a hidden class=anchor aria-hidden=true href=#事件发布者角色>#</a></h4><p><code>ApplicationEventPublisher</code> 充当了事件的发布者，它也是一个接口。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@FunctionalInterface</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ApplicationEventPublisher</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>default</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>publishEvent</span><span style=color:#f92672>(</span>ApplicationEvent event<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>publishEvent</span><span style=color:#f92672>((</span>Object<span style=color:#f92672>)</span>event<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>publishEvent</span><span style=color:#f92672>(</span>Object var1<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p><code>ApplicationEventPublisher</code> 接口的<code>publishEvent（）</code>这个方法在<code>AbstractApplicationContext</code>类中被实现，阅读这个方法的实现，你会发现实际上事件真正是通过<code>ApplicationEventMulticaster</code>来广播出去的。具体内容过多，就不在这里分析了，后面可能会单独写一篇文章提到。</p><h3 id=spring-的事件流程总结>Spring 的事件流程总结<a hidden class=anchor aria-hidden=true href=#spring-的事件流程总结>#</a></h3><ol><li>定义一个事件: 实现一个继承自 <code>ApplicationEvent</code>，并且写相应的构造函数；</li><li>定义一个事件监听者：实现 <code>ApplicationListener</code> 接口，重写 <code>onApplicationEvent()</code> 方法；</li><li>使用事件发布者发布消息: 可以通过 <code>ApplicationEventPublisher</code> 的 <code>publishEvent()</code> 方法发布消息。</li></ol><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 定义一个事件,继承自ApplicationEvent并且写相应的构造函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DemoEvent</span> <span style=color:#66d9ef>extends</span> ApplicationEvent<span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>long</span> serialVersionUID <span style=color:#f92672>=</span> 1L<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String message<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>DemoEvent</span><span style=color:#f92672>(</span>Object source<span style=color:#f92672>,</span>String message<span style=color:#f92672>){</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>super</span><span style=color:#f92672>(</span>source<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>message</span> <span style=color:#f92672>=</span> message<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>getMessage</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>return</span> message<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 定义一个事件监听者,实现ApplicationListener接口，重写 onApplicationEvent() 方法；
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>@Component</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DemoListener</span> <span style=color:#66d9ef>implements</span> ApplicationListener<span style=color:#f92672>&lt;</span>DemoEvent<span style=color:#f92672>&gt;{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//使用onApplicationEvent接收消息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>onApplicationEvent</span><span style=color:#f92672>(</span>DemoEvent event<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        String msg <span style=color:#f92672>=</span> event<span style=color:#f92672>.</span><span style=color:#a6e22e>getMessage</span><span style=color:#f92672>();</span>
</span></span><span style=display:flex><span>        System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;接收到的信息是：&#34;</span><span style=color:#f92672>+</span>msg<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 发布事件，可以通过ApplicationEventPublisher  的 publishEvent() 方法发布消息。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>@Component</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DemoPublisher</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    ApplicationContext applicationContext<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>publish</span><span style=color:#f92672>(</span>String message<span style=color:#f92672>){</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>//发布事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        applicationContext<span style=color:#f92672>.</span><span style=color:#a6e22e>publishEvent</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> DemoEvent<span style=color:#f92672>(</span><span style=color:#66d9ef>this</span><span style=color:#f92672>,</span> message<span style=color:#f92672>));</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>当调用 <code>DemoPublisher</code> 的 <code>publish()</code> 方法的时候，比如 <code>demoPublisher.publish("你好")</code> ，控制台就会打印出:<code>接收到的信息是：你好</code> 。</p><h2 id=适配器模式>适配器模式<a hidden class=anchor aria-hidden=true href=#适配器模式>#</a></h2><p>适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。</p><h3 id=spring-aop中的适配器模式>spring AOP中的适配器模式<a hidden class=anchor aria-hidden=true href=#spring-aop中的适配器模式>#</a></h3><p>我们知道 Spring AOP 的实现是基于代理模式，但是 Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是<code>AdvisorAdapter</code> 。Advice 常用的类型有：<code>BeforeAdvice</code>（目标方法调用前,前置通知）、<code>AfterAdvice</code>（目标方法调用后,后置通知）、<code>AfterReturningAdvice</code>(目标方法执行结束后，return之前)等等。每个类型Advice（通知）都有对应的拦截器:<code>MethodBeforeAdviceInterceptor</code>、<code>AfterReturningAdviceAdapter</code>、<code>AfterReturningAdviceInterceptor</code>。Spring预定义的通知要通过对应的适配器，适配成 <code>MethodInterceptor</code>接口(方法拦截器)类型的对象（如：<code>MethodBeforeAdviceInterceptor</code> 负责适配 <code>MethodBeforeAdvice</code>）。</p><h3 id=spring-mvc中的适配器模式>spring MVC中的适配器模式<a hidden class=anchor aria-hidden=true href=#spring-mvc中的适配器模式>#</a></h3><p>在Spring MVC中，<code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由<code>HandlerAdapter</code> 适配器处理。<code>HandlerAdapter</code> 作为期望接口，具体的适配器实现类用于对目标类进行适配，<code>Controller</code> 作为需要适配的类。</p><p><strong>为什么要在 Spring MVC 中使用适配器模式？</strong> Spring MVC 中的 <code>Controller</code> 种类众多，不同类型的 <code>Controller</code> 通过不同的方法来对请求进行处理。如果不利用适配器模式的话，<code>DispatcherServlet</code> 直接获取对应类型的 <code>Controller</code>，需要的自行来判断，像下面这段代码一样：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>if</span><span style=color:#f92672>(</span>mappedHandler<span style=color:#f92672>.</span><span style=color:#a6e22e>getHandler</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>instanceof</span> MultiActionController<span style=color:#f92672>){</span>  
</span></span><span style=display:flex><span>   <span style=color:#f92672>((</span>MultiActionController<span style=color:#f92672>)</span>mappedHandler<span style=color:#f92672>.</span><span style=color:#a6e22e>getHandler</span><span style=color:#f92672>()).</span><span style=color:#a6e22e>xxx</span>  
</span></span><span style=display:flex><span><span style=color:#f92672>}</span><span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span><span style=color:#f92672>(</span>mappedHandler<span style=color:#f92672>.</span><span style=color:#a6e22e>getHandler</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>instanceof</span> XXX<span style=color:#f92672>){</span>  
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>  
</span></span><span style=display:flex><span><span style=color:#f92672>}</span><span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span><span style=color:#f92672>(...){</span>  
</span></span><span style=display:flex><span>   <span style=color:#f92672>...</span>  
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>  
</span></span></code></pre></div><p>假如我们再增加一个 <code>Controller</code>类型就要在上面代码中再加入一行 判断语句，这种形式就使得程序难以维护，也违反了设计模式中的开闭原则 – 对扩展开放，对修改关闭。</p><h2 id=装饰者模式>装饰者模式<a hidden class=anchor aria-hidden=true href=#装饰者模式>#</a></h2><p>装饰者模式可以动态地给对象添加一些额外的属性或行为。相比于使用继承，装饰者模式更加灵活。简单点儿说就是当我们需要修改原有的功能，但我们又不愿直接去修改原有的代码时，设计一个Decorator套在原有代码外面。其实在 JDK 中就有很多地方用到了装饰者模式，比如 <code>InputStream</code>家族，<code>InputStream</code> 类下有 <code>FileInputStream</code> (读取文件)、<code>BufferedInputStream</code> (增加缓存,使读取文件速度大大提升)等子类都在不修改<code>InputStream</code> 代码的情况下扩展了它的功能。</p><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/swimminghao/picture@main/img/TRTmlJ_20210809143212.png alt=图片></p><center>装饰者模式示意图</center><p>Spring 中配置 DataSource 的时候，DataSource 可能是不同的数据库和数据源。我们能否根据客户的需求在少修改原有类的代码下动态切换不同的数据源？这个时候就要用到装饰者模式(这一点我自己还没太理解具体原理)。Spring 中用到的包装器模式在类名上含有 <code>Wrapper</code>或者 <code>Decorator</code>。这些类基本上都是动态地给一个对象添加一些额外的职责</p><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>Spring 框架中用到了哪些设计模式：</p><ul><li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li><li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li><li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li><li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li><li>……</li></ul><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><ul><li>《Spring技术内幕》</li><li><a href=https://blog.eduonix.com/java-programming-2/learn-design-patterns-used-spring-framework/>https://blog.eduonix.com/java-programming-2/learn-design-patterns-used-spring-framework/</a></li><li><a href=http://blog.yeamin.top/2018/03/27/>http://blog.yeamin.top/2018/03/27/</a>单例模式-Spring单例实现原理分析/</li><li><a href=https://www.tutorialsteacher.com/ioc/inversion-of-control>https://www.tutorialsteacher.com/ioc/inversion-of-control</a></li><li><a href=https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/observer.html>https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/observer.html</a></li><li><a href=https://juejin.im/post/5a8eb261f265da4e9e307230>https://juejin.im/post/5a8eb261f265da4e9e307230</a></li><li><a href=https://juejin.im/post/5ba28986f265da0abc2b6084>https://juejin.im/post/5ba28986f265da0abc2b6084</a></li></ul><div class=post-meta></hr>注：本作品采用<a rel=license target=view_window href=http://creativecommons.org/licenses/by-nc-sa/4.0/> 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议 </a>进行许可。</div></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.swimminghao.top/tags/%E9%9D%A2%E8%AF%95/>🏷 面试</a></li><li><a href=https://www.swimminghao.top/tags/%E8%AE%B0%E5%BD%95/>🏷 记录</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 面试官“谈谈Spring中都用到了那些设计模式”。 on twitter" href="https://twitter.com/intent/tweet/?text=%e9%9d%a2%e8%af%95%e5%ae%98%e2%80%9c%e8%b0%88%e8%b0%88Spring%e4%b8%ad%e9%83%bd%e7%94%a8%e5%88%b0%e4%ba%86%e9%82%a3%e4%ba%9b%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e2%80%9d%e3%80%82&url=https%3a%2f%2fwww.swimminghao.top%2fpost%2f02%25E4%25B8%25AA%25E4%25BA%25BA%25E5%25AD%25A6%25E4%25B9%25A0%2f06_03_%25E5%25AF%25B9%25E7%25BA%25BF%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%2598%2f%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%2598%25E8%25B0%2588%25E8%25B0%2588spring%25E4%25B8%25AD%25E9%2583%25BD%25E7%2594%25A8%25E5%2588%25B0%25E4%25BA%2586%25E9%2582%25A3%25E4%25BA%259B%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F%2f&hashtags=%e9%9d%a2%e8%af%95%2c%e8%ae%b0%e5%bd%95"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 面试官“谈谈Spring中都用到了那些设计模式”。 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fwww.swimminghao.top%2fpost%2f02%25E4%25B8%25AA%25E4%25BA%25BA%25E5%25AD%25A6%25E4%25B9%25A0%2f06_03_%25E5%25AF%25B9%25E7%25BA%25BF%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%2598%2f%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%2598%25E8%25B0%2588%25E8%25B0%2588spring%25E4%25B8%25AD%25E9%2583%25BD%25E7%2594%25A8%25E5%2588%25B0%25E4%25BA%2586%25E9%2582%25A3%25E4%25BA%259B%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F%2f&title=%e9%9d%a2%e8%af%95%e5%ae%98%e2%80%9c%e8%b0%88%e8%b0%88Spring%e4%b8%ad%e9%83%bd%e7%94%a8%e5%88%b0%e4%ba%86%e9%82%a3%e4%ba%9b%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e2%80%9d%e3%80%82&summary=%e9%9d%a2%e8%af%95%e5%ae%98%e2%80%9c%e8%b0%88%e8%b0%88Spring%e4%b8%ad%e9%83%bd%e7%94%a8%e5%88%b0%e4%ba%86%e9%82%a3%e4%ba%9b%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e2%80%9d%e3%80%82&source=https%3a%2f%2fwww.swimminghao.top%2fpost%2f02%25E4%25B8%25AA%25E4%25BA%25BA%25E5%25AD%25A6%25E4%25B9%25A0%2f06_03_%25E5%25AF%25B9%25E7%25BA%25BF%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%2598%2f%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%2598%25E8%25B0%2588%25E8%25B0%2588spring%25E4%25B8%25AD%25E9%2583%25BD%25E7%2594%25A8%25E5%2588%25B0%25E4%25BA%2586%25E9%2582%25A3%25E4%25BA%259B%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 面试官“谈谈Spring中都用到了那些设计模式”。 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.swimminghao.top%2fpost%2f02%25E4%25B8%25AA%25E4%25BA%25BA%25E5%25AD%25A6%25E4%25B9%25A0%2f06_03_%25E5%25AF%25B9%25E7%25BA%25BF%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%2598%2f%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%2598%25E8%25B0%2588%25E8%25B0%2588spring%25E4%25B8%25AD%25E9%2583%25BD%25E7%2594%25A8%25E5%2588%25B0%25E4%25BA%2586%25E9%2582%25A3%25E4%25BA%259B%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F%2f&title=%e9%9d%a2%e8%af%95%e5%ae%98%e2%80%9c%e8%b0%88%e8%b0%88Spring%e4%b8%ad%e9%83%bd%e7%94%a8%e5%88%b0%e4%ba%86%e9%82%a3%e4%ba%9b%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e2%80%9d%e3%80%82"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 面试官“谈谈Spring中都用到了那些设计模式”。 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.swimminghao.top%2fpost%2f02%25E4%25B8%25AA%25E4%25BA%25BA%25E5%25AD%25A6%25E4%25B9%25A0%2f06_03_%25E5%25AF%25B9%25E7%25BA%25BF%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%2598%2f%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%2598%25E8%25B0%2588%25E8%25B0%2588spring%25E4%25B8%25AD%25E9%2583%25BD%25E7%2594%25A8%25E5%2588%25B0%25E4%25BA%2586%25E9%2582%25A3%25E4%25BA%259B%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 面试官“谈谈Spring中都用到了那些设计模式”。 on whatsapp" href="https://api.whatsapp.com/send?text=%e9%9d%a2%e8%af%95%e5%ae%98%e2%80%9c%e8%b0%88%e8%b0%88Spring%e4%b8%ad%e9%83%bd%e7%94%a8%e5%88%b0%e4%ba%86%e9%82%a3%e4%ba%9b%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e2%80%9d%e3%80%82%20-%20https%3a%2f%2fwww.swimminghao.top%2fpost%2f02%25E4%25B8%25AA%25E4%25BA%25BA%25E5%25AD%25A6%25E4%25B9%25A0%2f06_03_%25E5%25AF%25B9%25E7%25BA%25BF%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%2598%2f%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%2598%25E8%25B0%2588%25E8%25B0%2588spring%25E4%25B8%25AD%25E9%2583%25BD%25E7%2594%25A8%25E5%2588%25B0%25E4%25BA%2586%25E9%2582%25A3%25E4%25BA%259B%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 面试官“谈谈Spring中都用到了那些设计模式”。 on telegram" href="https://telegram.me/share/url?text=%e9%9d%a2%e8%af%95%e5%ae%98%e2%80%9c%e8%b0%88%e8%b0%88Spring%e4%b8%ad%e9%83%bd%e7%94%a8%e5%88%b0%e4%ba%86%e9%82%a3%e4%ba%9b%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e2%80%9d%e3%80%82&url=https%3a%2f%2fwww.swimminghao.top%2fpost%2f02%25E4%25B8%25AA%25E4%25BA%25BA%25E5%25AD%25A6%25E4%25B9%25A0%2f06_03_%25E5%25AF%25B9%25E7%25BA%25BF%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%2598%2f%25E9%259D%25A2%25E8%25AF%2595%25E5%25AE%2598%25E8%25B0%2588%25E8%25B0%2588spring%25E4%25B8%25AD%25E9%2583%25BD%25E7%2594%25A8%25E5%2588%25B0%25E4%25BA%2586%25E9%2582%25A3%25E4%25BA%259B%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div><nav class=paginav><a class=prev href=https://www.swimminghao.top/post/02%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/06_02_java%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E5%AE%98%E8%AF%B4%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3class%E6%96%87%E4%BB%B6%E5%90%97/><span class=title>« 上一页</span><br><span>面试官：说说你了解class文件吗？</span></a>
<a class=next href=https://www.swimminghao.top/post/02%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/13_01_%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/leetcode/%E5%A6%82%E4%BD%95%E6%8B%86%E8%A7%A3%E5%A4%8D%E6%9D%82%E9%97%AE%E9%A2%98%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%AE%A1%E7%AE%97%E5%99%A8/><span class=title>下一页 »</span><br><span>如何拆解复杂问题：实现一个计算器</span></a></nav></footer></article></main><footer class=footer><span>Copyright &copy; 2023 • <a href=https://www.swimminghao.top/>swimminghao</a></span><div><span><a href=/about/>关于</a>
• <a href=/disclaimer/>免责声明</a>
• <a href=/sitemap.xml target=view_window>站点地图</a>
• <a href=https://www.foreverblog.cn/go.html target=view_window>虫洞</a>
• PV <span id=busuanzi_value_site_pv><i class="fa fa-spinner fa-spin"></i></span></span></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><meta name=”apple-mobile-web-app-capable” content="”yes”"><script>"serviceWorker"in navigator&&window.addEventListener("load",()=>{navigator.serviceWorker.register("/service-worker.js")})</script></body></html>