<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Spring SchedulingConfigurer实现动态定时任务(修改) | swimminghao</title><meta name=keywords content="java"><meta name=description content="Spring SchedulingConfigurer 实现动态定时任务 一、前言 大家在日常工作中，一定使用过 Spring 的 @Scheduled 注解吧，通过该注解可以非常方便的帮助我们实现任务的定时执行。 但是该注解是不支持"><meta name=author content="swimminghao"><link rel=canonical href=https://swimminghao1.github.io/post/02%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/06_02_java%E9%9D%A2%E8%AF%95/spring-schedulingconfigurer-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/><meta name=yandex-verification content="73b1a797f62c0e98"><meta name=baidu-site-verification content="code-gnOrbP1RyC"><meta name=baidu_union_verify content="4c552c344295cb984c46ebe74962b067"><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/satouriko/LxgwWenKai_Webfonts@v1.101/dist/LXGWWenKai-Light.css><link crossorigin=anonymous href=/assets/css/stylesheet.min.0a5d9aa21e56d0b7d41b1d4b56af0b911caf526faf5060a8d3717579bf27cb93.css integrity="sha256-Cl2aoh5W0LfUGx1LVq8LkRyvUm+vUGCo03F1eb8ny5M=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://swimminghao1.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://swimminghao1.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://swimminghao1.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://swimminghao1.github.io/apple-touch-icon.png><link rel=mask-icon href=https://swimminghao1.github.io/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.97.0"><link rel=manifest href=/manifest.json><script type=text/javascript>function downloadJSAtOnload(){var e=document.createElement("script");e.src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7296634171837358",document.body.appendChild(e)}window.addEventListener?window.addEventListener("load",downloadJSAtOnload,!1):window.attachEvent?window.attachEvent("onload",downloadJSAtOnload):window.onload=downloadJSAtOnload</script><script async defer data-website-id=3d947a98-2774-46b0-805f-fe2e4877a1d7 src=https://umami.frytea.com/umami.js></script>
<script async src=https://swimminghao1.github.io/js/busuanzi.pure.mini.js></script>
<link rel=stylesheet href=/libs/font-awesome-4.7.0/css/font-awesome.min.css><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://swimminghao1.github.io/js/mermaid.min.js crossorigin=anonymous></script>
<script>const config={startOnLoad:!0,theme:"forest",themeVariables:{lineColor:"#fafafa"},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))}</script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?c49e2f5be5e009382be07455c33b1394",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-136094326-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Spring SchedulingConfigurer实现动态定时任务(修改)"><meta property="og:description" content="Spring SchedulingConfigurer 实现动态定时任务 一、前言 大家在日常工作中，一定使用过 Spring 的 @Scheduled 注解吧，通过该注解可以非常方便的帮助我们实现任务的定时执行。 但是该注解是不支持"><meta property="og:type" content="article"><meta property="og:url" content="https://swimminghao1.github.io/post/02%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/06_02_java%E9%9D%A2%E8%AF%95/spring-schedulingconfigurer-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"><meta property="og:image" content="https://swimminghao1.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-02-28T19:57:47+00:00"><meta property="article:modified_time" content="2022-02-28T19:57:47+00:00"><meta property="og:site_name" content="swimminghao"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://swimminghao1.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Spring SchedulingConfigurer实现动态定时任务(修改)"><meta name=twitter:description content="Spring SchedulingConfigurer 实现动态定时任务 一、前言 大家在日常工作中，一定使用过 Spring 的 @Scheduled 注解吧，通过该注解可以非常方便的帮助我们实现任务的定时执行。 但是该注解是不支持"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"📚文章","item":"https://swimminghao1.github.io/post/"},{"@type":"ListItem","position":2,"name":"Spring SchedulingConfigurer实现动态定时任务(修改)","item":"https://swimminghao1.github.io/post/02%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/06_02_java%E9%9D%A2%E8%AF%95/spring-schedulingconfigurer-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Spring SchedulingConfigurer实现动态定时任务(修改)","name":"Spring SchedulingConfigurer实现动态定时任务(修改)","description":"Spring SchedulingConfigurer 实现动态定时任务 一、前言 大家在日常工作中，一定使用过 Spring 的 @Scheduled 注解吧，通过该注解可以非常方便的帮助我们实现任务的定时执行。 但是该注解是不支持","keywords":["java"],"articleBody":"Spring SchedulingConfigurer 实现动态定时任务 一、前言 大家在日常工作中，一定使用过 Spring 的 @Scheduled 注解吧，通过该注解可以非常方便的帮助我们实现任务的定时执行。\n但是该注解是不支持运行时动态修改执行间隔的，不知道你在业务中有没有这些需求和痛点：\n在服务运行时能够动态修改定时任务的执行频率和执行开关，而无需重启服务和修改代码 能够基于配置，在不同环境/机器上，实现定时任务执行频率的差异化 这些都可以通过 Spring 的 SchedulingConfigurer 注解来实现。\n这个注解其实大家并不陌生，如果有使用过 @Scheduled 的话，因为 @Scheduled 默认是单线程执行的，因此如果存在多个任务同时触发，可能触发阻塞。使用 SchedulingConfigurer 可以配置用于执行 @Scheduled 的线程池，来避免这个问题。\nJAVA @Configuration public class ScheduleConfig implements SchedulingConfigurer { @Override public void configureTasks(ScheduledTaskRegistrar taskRegistrar) { //设定一个长度10的定时任务线程池 taskRegistrar.setScheduler(Executors.newScheduledThreadPool(10)); } } 但其实这个接口，还可以实现动态定时任务的功能，下面来演示如何实现。\n二、功能实现 后续定义的类开头的 DS 是 Dynamic Schedule 的缩写。\n使用到的依赖，除了 Spring 外，还包括：\nXML  org.apache.commons commons-lang3 \n org.apache.commons commons-collections4 4.4   org.projectlombok lombok provided 1.18.18  2.1 @EnableScheduling 首先需要开启 @EnableScheduling 注解，直接在启动类添加即可： JAVA @EnableScheduling @SpringBootApplication public class DSApplication { public static void main(String[] args) { SpringApplication.run(DSApplication.class, args); } } 2.2 IDSTaskInfo 定义一个任务信息的接口，后续所有用于动态调整的任务信息对象，都需要实现该接口。\nid：该任务信息的唯一 ID，用于唯一标识一个任务 cron：该任务执行的 cron 表达式。 isValid：任务开关 isChange：用于标识任务参数是否发生了改变 JAVA public interface IDSTaskInfo { /** * 任务 ID */ long getId();\n/** * 任务执行 cron 表达式 */ String getCron(); /** * 任务是否有效 */ boolean isValid(); /** * 判断任务是否发生变化 */ boolean isChange(IDSTaskInfo oldTaskInfo);  } 2.3 DSContainer 顾名思义，是存放 IDSTaskInfo 的容器。\n具有以下成员变量：\nscheduleMap：用于暂存 IDSTaskInfo 和实际任务 ScheduledTask 的映射关系。其中： task_id：作为主键，确保一个 IDSTaskInfo 只会被注册进一次 T：暂存当初注册时的 IDSTaskInfo，用于跟最新的 IDSTaskInfo 比较参数是否发生变化 ScheduledTask：暂存当初注册时生成的任务，如果需要取消任务的话，需要拿到该对象 Semaphore：确保每个任务实际执行时只有一个线程执行，不会产生并发问题 taskRegistrar：Spring 的任务注册管理器，用于注册任务到 Spring 容器中 name：调用方提供的类名 具有以下成员方法：\nvoid checkTask(final T taskInfo, final TriggerTask triggerTask)：检查 IDSTaskInfo，判断是否需要注册/取消任务。具体的逻辑包括： 如果任务已经注册： 如果任务无效：则取消任务 如果任务有效： 如果任务配置发生了变化：则取消任务并重新注册任务 如果任务没有注册： 如果任务有效：则注册任务 Semaphore getSemaphore()：获取信号量属性。 JAVA import lombok.extern.slf4j.Slf4j; import org.apache.commons.lang3.tuple.Pair; import org.springframework.scheduling.config.ScheduledTask; import org.springframework.scheduling.config.ScheduledTaskRegistrar; import org.springframework.scheduling.config.TriggerTask;\nimport java.util.Map; import java.util.concurrent.ConcurrentHashMap; import java.util.concurrent.Semaphore;\n/**\n  存放 IDSTaskInfo 容器\n  @author jitwxs\n  @date 2021年03月27日 16:29 / @Slf4j public class DSContainer{ /*\n IDSTaskInfo和真实任务的关联关系  */ private final MapscheduleMap = new ConcurrentHashMap();  private final ScheduledTaskRegistrar taskRegistrar;\nprivate final String name;\npublic DSContainer(ScheduledTaskRegistrar scheduledTaskRegistrar, final String name) { this.taskRegistrar = scheduledTaskRegistrar; this.name = name; }\n/**\n  注册任务\n  @param taskInfo 任务信息\n  @param triggerTask 任务的触发规则 */ public void checkTask(final T taskInfo, final TriggerTask triggerTask) { final long taskId = taskInfo.getId();\nif (scheduleMap.containsKey(taskId)) { if (taskInfo.isValid()) { final T oldTaskInfo = scheduleMap.get(taskId).getLeft();\n if(oldTaskInfo.isChange(taskInfo)) { log.info(\"DSContainer will register {} again because task config change, taskId: {}\", name, taskId); cancelTask(taskId); registerTask(taskInfo, triggerTask); } } else { log.info(\"DSContainer will cancelTask {} because task not valid, taskId: {}\", name, taskId); cancelTask(taskId); }  } else { if (taskInfo.isValid()) { log.info(“DSContainer will register {} task, taskId: {}”, name, taskId); registerTask(taskInfo, triggerTask); } } }\n  /**\n 获取 Semaphore，确保任务不会被多个线程同时执行 */ public Semaphore getSemaphore(final long taskId) { return this.scheduleMap.get(taskId).getRight().getRight(); }  private void registerTask(final T taskInfo, final TriggerTask triggerTask) { final ScheduledTask latestTask = taskRegistrar.scheduleTriggerTask(triggerTask); this.scheduleMap.put(taskInfo.getId(), Pair.of(taskInfo, Pair.of(latestTask, new Semaphore(1)))); }\nprivate void cancelTask(final long taskId) { final Pair 具有以下抽象方法：\nList listTaskInfo()：获取所有的任务信息。 void doProcess(T taskInfo)：实现实际执行任务的业务逻辑。 具有以下公共方法：\nvoid configureTasks(ScheduledTaskRegistrar taskRegistrar)：创建 DSContainer 对象，并创建一个单线程的任务定时执行，调用 scheduleTask() 方法处理实际逻辑。 void scheduleTask()：首先加载所有任务信息，然后基于 cron 表达式生成 TriggerTask 对象，调用 checkTask() 方法确认是否需要注册/取消任务。当达到执行时间时，调用 execute() 方法，执行任务逻辑。 void execute(final T taskInfo)：获取信号量，成功后执行任务逻辑。 JAVA import lombok.extern.slf4j.Slf4j; import org.apache.commons.collections4.CollectionUtils; import org.springframework.scheduling.annotation.SchedulingConfigurer; import org.springframework.scheduling.config.ScheduledTaskRegistrar; import org.springframework.scheduling.config.TriggerTask; import org.springframework.scheduling.support.CronTrigger;\nimport java.util.List; import java.util.Objects; import java.util.concurrent.Semaphore; import java.util.concurrent.TimeUnit;\n/**\n  抽象 Dynamic Schedule 实现，基于 SchedulingConfigurer 实现\n  @author jitwxs\n  @date 2021年03月27日 16:41 */ @Slf4j public abstract class AbstractDSHandlerimplements SchedulingConfigurer {\nprivate DSContainer dsContainer;\nprivate final String CLASS_NAME = getClass().getSimpleName();\n/**\n 获取所有的任务信息 */ protected abstract List listTaskInfo();  /**\n 做具体的任务逻辑    该方法执行时位于跟 SpringBoot @Scheduled 注解相同的线程池内。如果内部仍需要开子线程池执行，请务必同步等待子线程池执行完毕，否则可能会影响预期效果。   */ protected abstract void doProcess(T taskInfo) throws Throwable;\n@Override public void configureTasks(ScheduledTaskRegistrar taskRegistrar) { dsContainer = new DSContainer(taskRegistrar, CLASS_NAME); // 每隔 100ms 调度一次，用于读取所有任务 taskRegistrar.addFixedDelayTask(this::scheduleTask, 1000); }\n/**\n 调度任务，加载所有任务并注册 */ private void scheduleTask() { CollectionUtils.emptyIfNull(listTaskInfo()).forEach(taskInfo - dsContainer.checkTask(taskInfo, new TriggerTask(() - this.execute(taskInfo), triggerContext - new CronTrigger(taskInfo.getCron()).nextExecutionTime(triggerContext) )) ); }  private void execute(final T taskInfo) { final long taskId = taskInfo.getId();\n try { Semaphore semaphore = dsContainer.getSemaphore(taskId); if (Objects.isNull(semaphore)) { log.error(\"{} semaphore is null, taskId: {}\", CLASS_NAME, taskId); return; } if (semaphore.tryAcquire(3, TimeUnit.SECONDS)) { try { doProcess(taskInfo); } catch (Throwable throwable) { log.error(\"{} doProcess error, taskId: {}\", CLASS_NAME, taskId, throwable); } finally { semaphore.release(); } } else { log.warn(\"{} too many executor, taskId: {}\", CLASS_NAME, taskId); } } catch (InterruptedException e) { log.warn(\"{} interruptedException error, taskId: {}\", CLASS_NAME, taskId); } catch (Exception e) { log.error(\"{} execute error, taskId: {}\", CLASS_NAME, taskId, e); }  } } 三、快速测试 至此就完成了动态任务的框架搭建，下面让我们来快速测试下。为了尽量减少其他技术带来的复杂度，本次测试不涉及数据库和真实的定时任务，完全采用模拟实现。\n  3.1 模拟定时任务 为了模拟一个定时任务，我定义了一个 foo() 方法，其中只输出一句话。后续我将通过定时调用该方法，来模拟定时任务。\nJAVA import lombok.extern.slf4j.Slf4j;\nimport java.time.LocalTime;\n@Slf4j public class SchedulerTest { public void foo() { log.info(\"{} Execute com.github.jitwxs.sample.ds.test.SchedulerTest#foo\", LocalTime.now()); } } 3.2 实现 IDSTaskInfo 首先定义 IDSTaskInfo，我这里想通过反射来实现调用 foo() 方法，因此 reference 表示的是要调用方法的全路径。另外我实现了 isChange() 方法，只要 cron、isValid、reference 发生了变动，就认为该任务的配置发生了改变。\nJAVA import com.github.jitwxs.sample.ds.config.IDSTaskInfo; import lombok.Builder; import lombok.Data;\n@Data @Builder public class SchedulerTestTaskInfo implements IDSTaskInfo { private long id;\nprivate String cron; private boolean isValid; private String reference; @Override public boolean isChange(IDSTaskInfo oldTaskInfo) { if(oldTaskInfo instanceof SchedulerTestTaskInfo) { final SchedulerTestTaskInfo obj = (SchedulerTestTaskInfo) oldTaskInfo; return !this.cron.equals(obj.cron) || this.isValid != obj.isValid || !this.reference.equals(obj.getReference()); } else { throw new IllegalArgumentException(\"Not Support SchedulerTestTaskInfo type\"); } }  } 3.3 实现 AbstractDSHandler 有几个需要关注的：\n（1）listTaskInfo() 返回值我使用了 volatile 变量，便于我修改它，模拟任务信息数据的改变。\n（2）doProcess() 方法中，读取到 reference 后，使用反射进行调用，模拟定时任务的执行。\n（3）额外实现了 ApplicationListener 接口，当服务启动后，每隔一段时间修改下任务信息，模拟业务中调整配置。\n服务启动后，foo() 定时任务将每 10s 执行一次。 10s 后，将 foo() 定时任务执行周期从每 10s 执行调整为 1s 执行。 10s 后，关闭 foo() 定时任务执行。 10s 后，开启 foo() 定时任务执行。 JAVA import com.github.jitwxs.sample.ds.config.AbstractDSHandler; import org.springframework.context.ApplicationEvent; import org.springframework.context.ApplicationListener; import org.springframework.stereotype.Component;\nimport java.lang.reflect.Method; import java.util.Collections; import java.util.List; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; import java.util.concurrent.locks.LockSupport;\n/**\n  @author jitwxs\n  @date 2021年03月27日 21:54 */ @Component public class SchedulerTestDSHandler extends AbstractDSHandler implements ApplicationListener { public volatile List taskInfoList = Collections.singletonList( SchedulerTestTaskInfo.builder() .id(1) .cron(“0/10 * * * * ? “) .isValid(true) .reference(“com.github.jitwxs.sample.ds.test.SchedulerTest#foo”) .build() );\n@Override protected List listTaskInfo() { return taskInfoList; }\n@Override protected void doProcess(SchedulerTestTaskInfo taskInfo) throws Throwable { final String reference = taskInfo.getReference(); final String[] split = reference.split(”#”); if(split.length != 2) { return; }\ntry { final Class clazz = Class.forName(split[0]); final Method method = clazz.getMethod(split[1]); method.invoke(clazz.newInstance()); } catch (Exception e) { e.printStackTrace(); }  }\n@Override public void onApplicationEvent(ApplicationEvent applicationEvent) { Executors.newScheduledThreadPool(1).scheduleAtFixedRate(() - { LockSupport.parkNanos(TimeUnit.SECONDS.toNanos(10));\n // setting 1 seconds execute taskInfoList = Collections.singletonList( SchedulerTestTaskInfo.builder() .id(1) .cron(\"0/1 * * * * ? \") .isValid(true) .reference(\"com.github.jitwxs.sample.ds.test.SchedulerTest#foo\") .build() ); LockSupport.parkNanos(TimeUnit.SECONDS.toNanos(10)); // setting not valid taskInfoList = Collections.singletonList( SchedulerTestTaskInfo.builder() .id(1) .cron(\"0/1 * * * * ? \") .isValid(false) .reference(\"com.github.jitwxs.sample.ds.test.SchedulerTest#foo\") .build() ); LockSupport.parkNanos(TimeUnit.SECONDS.toNanos(10)); // setting valid taskInfoList = Collections.singletonList( SchedulerTestTaskInfo.builder() .id(1) .cron(\"0/1 * * * * ? \") .isValid(true) .reference(\"com.github.jitwxs.sample.ds.test.SchedulerTest#foo\") .build() ); }, 12, 86400, TimeUnit.SECONDS);  } } 3.4 运行程序 整个应用包结构如下：\n  包结构\n运行程序后，在控制台可以观测到如下输出：\n运行结果\n四、后记 以上完成了动态定时任务的介绍，你能够根据本篇文章，实现以下需求吗：\n本文基于 cron 表达式实现了频率控制，你能改用 fixedDelay 或 fixedRate 实现吗？ 基于数据库/配置文件/配置中心，实现对服务中定时任务的动态频率调整和任务的启停。 开发一个数据表历史数据清理功能，能够动态配置要清理的表、清理的规则、清理的周期。 开发一个数据表异常数据告警功能，能够动态配置要扫描的表、告警的规则、扫描的周期。\n","wordCount":"2872","inLanguage":"zh","datePublished":"2022-02-28T19:57:47Z","dateModified":"2022-02-28T19:57:47Z","author":{"@type":"Person","name":"swimminghao"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://swimminghao1.github.io/post/02%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/06_02_java%E9%9D%A2%E8%AF%95/spring-schedulingconfigurer-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"},"publisher":{"@type":"Organization","name":"swimminghao","logo":{"@type":"ImageObject","url":"https://swimminghao1.github.io/favicon.ico"}}}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://swimminghao1.github.io/ accesskey=h title="🍀 swimminghao (Alt + H)">🍀 swimminghao</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://swimminghao1.github.io/categories/ title="🗂 归类"><span>🗂 归类</span></a></li><li><a href=https://swimminghao1.github.io/tags/ title="🏷️ 标签"><span>🏷️ 标签</span></a></li><li><a href=https://swimminghao1.github.io/archives/ title="⏱️ 时间轴"><span>⏱️ 时间轴</span></a></li><li><a href=https://swimminghao1.github.io/search/ title="🔍 索引 (Alt + /)" accesskey=/><span>🔍 索引</span></a></li><li><a href=https://swimminghao1.github.io/friends title="🧑‍🤝‍🧑 友链"><span>🧑‍🤝‍🧑 友链</span></a></li><li><a href=https://www.travellings.cn/go.html title=🚇><span>🚇</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://swimminghao1.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://swimminghao1.github.io/post/>📚文章</a></div><h1 class=post-title><a href=https://swimminghao1.github.io/post/02%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/06_02_java%E9%9D%A2%E8%AF%95/spring-schedulingconfigurer-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/>Spring SchedulingConfigurer实现动态定时任务(修改)</a></h1><div class=post-meta>February 28, 2022&nbsp;·&nbsp;6 分钟&nbsp;·&nbsp;2872 字&nbsp;·&nbsp;swimminghao&nbsp;|&nbsp;<a href=https://github.com/songtianlun/songtianlun.github.io/edit/main/content/post/02%e4%b8%aa%e4%ba%ba%e5%ad%a6%e4%b9%a0/06_02_java%e9%9d%a2%e8%af%95/Spring%20SchedulingConfigurer%20%e5%ae%9e%e7%8e%b0%e5%8a%a8%e6%80%81%e5%ae%9a%e6%97%b6%e4%bb%bb%e5%8a%a1.md rel="noopener noreferrer" target=_blank>PR</a>
<span>| <span class=waline-pageview-count data-path=/post/02%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/06_02_java%E9%9D%A2%E8%AF%95/spring-schedulingconfigurer-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/><i class="fa fa-spinner fa-spin"></i></span> Hits</span></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#spring-schedulingconfigurer-%e5%ae%9e%e7%8e%b0%e5%8a%a8%e6%80%81%e5%ae%9a%e6%97%b6%e4%bb%bb%e5%8a%a1 aria-label="Spring SchedulingConfigurer 实现动态定时任务">Spring SchedulingConfigurer 实现动态定时任务</a></li></ul></div><div><ins class=adsbygoogle style=display:block data-ad-client=ca-pub-7296634171837358 data-ad-slot=9161921641 data-ad-format=auto data-full-width-responsive=true></ins></div><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></details></div><div class=post-content><blockquote style=margin-top:8px><p style=text-align:center;text-indent:0><a href=https://swimminghao1.github.io/post/02%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/06_02_java%E9%9D%A2%E8%AF%95/spring-schedulingconfigurer-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/>本文</a>
首发于
<a href=https://swimminghao1.github.io/>🍀 永浩</a>，
<a href=/disclaimer/>转载</a> 请注明
<a href=https://swimminghao1.github.io/post/02%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/06_02_java%E9%9D%A2%E8%AF%95/spring-schedulingconfigurer-%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/>来源</a>。</p></blockquote><h1 id=spring-schedulingconfigurer-实现动态定时任务>Spring SchedulingConfigurer 实现动态定时任务<a hidden class=anchor aria-hidden=true href=#spring-schedulingconfigurer-实现动态定时任务>#</a></h1><p>一、前言
大家在日常工作中，一定使用过 Spring 的 @Scheduled 注解吧，通过该注解可以非常方便的帮助我们实现任务的定时执行。</p><p>但是该注解是不支持运行时动态修改执行间隔的，不知道你在业务中有没有这些需求和痛点：</p><p>在服务运行时能够动态修改定时任务的执行频率和执行开关，而无需重启服务和修改代码
能够基于配置，在不同环境/机器上，实现定时任务执行频率的差异化
这些都可以通过 Spring 的 SchedulingConfigurer 注解来实现。</p><p>这个注解其实大家并不陌生，如果有使用过 @Scheduled 的话，因为 @Scheduled 默认是单线程执行的，因此如果存在多个任务同时触发，可能触发阻塞。使用 SchedulingConfigurer 可以配置用于执行 @Scheduled 的线程池，来避免这个问题。</p><p>JAVA
@Configuration
public class ScheduleConfig implements SchedulingConfigurer {
@Override
public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
//设定一个长度10的定时任务线程池
taskRegistrar.setScheduler(Executors.newScheduledThreadPool(10));
}
}
但其实这个接口，还可以实现动态定时任务的功能，下面来演示如何实现。</p><p>二、功能实现
后续定义的类开头的 DS 是 Dynamic Schedule 的缩写。</p><p>使用到的依赖，除了 Spring 外，还包括：</p><p>XML
<dependency><groupid>org.apache.commons</groupid>
<artifactid>commons-lang3</artifactid></dependency></p><dependency><groupid>org.apache.commons</groupid>
<artifactid>commons-collections4</artifactid>
<version>4.4</version></dependency>
<dependency><groupid>org.projectlombok</groupid>
<artifactid>lombok</artifactid>
<scope>provided</scope>
<version>1.18.18</version></dependency>
2.1 @EnableScheduling
首先需要开启 @EnableScheduling 注解，直接在启动类添加即可：<p>JAVA
@EnableScheduling
@SpringBootApplication
public class DSApplication {
public static void main(String[] args) {
SpringApplication.run(DSApplication.class, args);
}
}
2.2 IDSTaskInfo
定义一个任务信息的接口，后续所有用于动态调整的任务信息对象，都需要实现该接口。</p><p>id：该任务信息的唯一 ID，用于唯一标识一个任务
cron：该任务执行的 cron 表达式。
isValid：任务开关
isChange：用于标识任务参数是否发生了改变
JAVA
public interface IDSTaskInfo {
/**
* 任务 ID
*/
long getId();</p><pre><code>/**
 * 任务执行 cron 表达式
 */
String getCron();

/**
 * 任务是否有效
 */
boolean isValid();

/**
 * 判断任务是否发生变化
 */
boolean isChange(IDSTaskInfo oldTaskInfo);
</code></pre><p>}
2.3 DSContainer
顾名思义，是存放 IDSTaskInfo 的容器。</p><p>具有以下成员变量：</p><p>scheduleMap：用于暂存 IDSTaskInfo 和实际任务 ScheduledTask 的映射关系。其中：
task_id：作为主键，确保一个 IDSTaskInfo 只会被注册进一次
T：暂存当初注册时的 IDSTaskInfo，用于跟最新的 IDSTaskInfo 比较参数是否发生变化
ScheduledTask：暂存当初注册时生成的任务，如果需要取消任务的话，需要拿到该对象
Semaphore：确保每个任务实际执行时只有一个线程执行，不会产生并发问题
taskRegistrar：Spring 的任务注册管理器，用于注册任务到 Spring 容器中
name：调用方提供的类名
具有以下成员方法：</p><p>void checkTask(final T taskInfo, final TriggerTask triggerTask)：检查 IDSTaskInfo，判断是否需要注册/取消任务。具体的逻辑包括：
如果任务已经注册：
如果任务无效：则取消任务
如果任务有效：
如果任务配置发生了变化：则取消任务并重新注册任务
如果任务没有注册：
如果任务有效：则注册任务
Semaphore getSemaphore()：获取信号量属性。
JAVA
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.tuple.Pair;
import org.springframework.scheduling.config.ScheduledTask;
import org.springframework.scheduling.config.ScheduledTaskRegistrar;
import org.springframework.scheduling.config.TriggerTask;</p><p>import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Semaphore;</p><p>/**</p><ul><li><p>存放 IDSTaskInfo 容器</p></li><li><p>@author jitwxs</p></li><li><p>@date 2021年03月27日 16:29
<em>/
@Slf4j
public class DSContainer<t extends idstaskinfo> {
/</em>*</p><ul><li>IDSTaskInfo和真实任务的关联关系</li><li></li><li>&lt;task_id, &lt;Task, &lt;Scheduled, Semaphore&#187;>
*/
private final Map&lt;Long, Pair&lt;T, Pair&lt;ScheduledTask, Semaphore&#187;> scheduleMap = new ConcurrentHashMap&lt;>();</li></ul><p>private final ScheduledTaskRegistrar taskRegistrar;</p><p>private final String name;</p><p>public DSContainer(ScheduledTaskRegistrar scheduledTaskRegistrar, final String name) {
this.taskRegistrar = scheduledTaskRegistrar;
this.name = name;
}</p><p>/**</p><ul><li><p>注册任务</p></li><li><p>@param taskInfo 任务信息</p></li><li><p>@param triggerTask 任务的触发规则
*/
public void checkTask(final T taskInfo, final TriggerTask triggerTask) {
final long taskId = taskInfo.getId();</p><p>if (scheduleMap.containsKey(taskId)) {
if (taskInfo.isValid()) {
final T oldTaskInfo = scheduleMap.get(taskId).getLeft();</p><pre><code>     if(oldTaskInfo.isChange(taskInfo)) {
         log.info(&quot;DSContainer will register {} again because task config change, taskId: {}&quot;, name, taskId);
         cancelTask(taskId);
         registerTask(taskInfo, triggerTask);
     }
 } else {
     log.info(&quot;DSContainer will cancelTask {} because task not valid, taskId: {}&quot;, name, taskId);
     cancelTask(taskId);
 }
</code></pre><p>} else {
if (taskInfo.isValid()) {
log.info(&ldquo;DSContainer will register {} task, taskId: {}&rdquo;, name, taskId);
registerTask(taskInfo, triggerTask);
}
}
}</p></li></ul><p>/**</p><ul><li>获取 Semaphore，确保任务不会被多个线程同时执行
*/
public Semaphore getSemaphore(final long taskId) {
return this.scheduleMap.get(taskId).getRight().getRight();
}</li></ul><p>private void registerTask(final T taskInfo, final TriggerTask triggerTask) {
final ScheduledTask latestTask = taskRegistrar.scheduleTriggerTask(triggerTask);
this.scheduleMap.put(taskInfo.getId(), Pair.of(taskInfo, Pair.of(latestTask, new Semaphore(1))));
}</p><p>private void cancelTask(final long taskId) {
final Pair&lt;T, Pair&lt;ScheduledTask, Semaphore&#187; pair = this.scheduleMap.remove(taskId);
if (pair != null) {
pair.getRight().getLeft().cancel();
}
}
}
2.4 AbstractDSHandler
下面定义实际的动态线程池处理方法，这里采用抽象类实现，将共用逻辑封装起来，方便扩展。</p></li></ul><p>具有以下抽象方法：</p><p>List<t> listTaskInfo()：获取所有的任务信息。
void doProcess(T taskInfo)：实现实际执行任务的业务逻辑。
具有以下公共方法：</p><p>void configureTasks(ScheduledTaskRegistrar taskRegistrar)：创建 DSContainer 对象，并创建一个单线程的任务定时执行，调用 scheduleTask() 方法处理实际逻辑。
void scheduleTask()：首先加载所有任务信息，然后基于 cron 表达式生成 TriggerTask 对象，调用 checkTask() 方法确认是否需要注册/取消任务。当达到执行时间时，调用 execute() 方法，执行任务逻辑。
void execute(final T taskInfo)：获取信号量，成功后执行任务逻辑。
JAVA
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.collections4.CollectionUtils;
import org.springframework.scheduling.annotation.SchedulingConfigurer;
import org.springframework.scheduling.config.ScheduledTaskRegistrar;
import org.springframework.scheduling.config.TriggerTask;
import org.springframework.scheduling.support.CronTrigger;</p><p>import java.util.List;
import java.util.Objects;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;</p><p>/**</p><ul><li><p>抽象 Dynamic Schedule 实现，基于 SchedulingConfigurer 实现</p></li><li><p>@author jitwxs</p></li><li><p>@date 2021年03月27日 16:41
*/
@Slf4j
public abstract class AbstractDSHandler<t extends idstaskinfo> implements SchedulingConfigurer {</p><p>private DSContainer<t> dsContainer;</p><p>private final String CLASS_NAME = getClass().getSimpleName();</p><p>/**</p><ul><li>获取所有的任务信息
*/
protected abstract List<t> listTaskInfo();</li></ul><p>/**</p><ul><li>做具体的任务逻辑</li><li></li><li><p>该方法执行时位于跟 SpringBoot @Scheduled 注解相同的线程池内。如果内部仍需要开子线程池执行，请务必同步等待子线程池执行完毕，否则可能会影响预期效果。</li></ul><p>*/
protected abstract void doProcess(T taskInfo) throws Throwable;</p><p>@Override
public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
dsContainer = new DSContainer&lt;>(taskRegistrar, CLASS_NAME);
// 每隔 100ms 调度一次，用于读取所有任务
taskRegistrar.addFixedDelayTask(this::scheduleTask, 1000);
}</p><p>/**</p><ul><li>调度任务，加载所有任务并注册
*/
private void scheduleTask() {
CollectionUtils.emptyIfNull(listTaskInfo()).forEach(taskInfo ->
dsContainer.checkTask(taskInfo, new TriggerTask(() ->
this.execute(taskInfo), triggerContext -> new CronTrigger(taskInfo.getCron()).nextExecutionTime(triggerContext)
))
);
}</li></ul><p>private void execute(final T taskInfo) {
final long taskId = taskInfo.getId();</p><pre><code> try {
     Semaphore semaphore = dsContainer.getSemaphore(taskId);
     if (Objects.isNull(semaphore)) {
         log.error(&quot;{} semaphore is null, taskId: {}&quot;, CLASS_NAME, taskId);
         return;
     }
     if (semaphore.tryAcquire(3, TimeUnit.SECONDS)) {
         try {
             doProcess(taskInfo);
         } catch (Throwable throwable) {
             log.error(&quot;{} doProcess error, taskId: {}&quot;, CLASS_NAME, taskId, throwable);
         } finally {
             semaphore.release();
         }
     } else {
         log.warn(&quot;{} too many executor, taskId: {}&quot;, CLASS_NAME, taskId);
     }
 } catch (InterruptedException e) {
     log.warn(&quot;{} interruptedException error, taskId: {}&quot;, CLASS_NAME, taskId);
 } catch (Exception e) {
     log.error(&quot;{} execute error, taskId: {}&quot;, CLASS_NAME, taskId, e);
 }
</code></pre><p>}
}
三、快速测试
至此就完成了动态任务的框架搭建，下面让我们来快速测试下。为了尽量减少其他技术带来的复杂度，本次测试不涉及数据库和真实的定时任务，完全采用模拟实现。</p></li></ul><p>3.1 模拟定时任务
为了模拟一个定时任务，我定义了一个 foo() 方法，其中只输出一句话。后续我将通过定时调用该方法，来模拟定时任务。</p><p>JAVA
import lombok.extern.slf4j.Slf4j;</p><p>import java.time.LocalTime;</p><p>@Slf4j
public class SchedulerTest {
public void foo() {
log.info("{} Execute com.github.jitwxs.sample.ds.test.SchedulerTest#foo", LocalTime.now());
}
}
3.2 实现 IDSTaskInfo
首先定义 IDSTaskInfo，我这里想通过反射来实现调用 foo() 方法，因此 reference 表示的是要调用方法的全路径。另外我实现了 isChange() 方法，只要 cron、isValid、reference 发生了变动，就认为该任务的配置发生了改变。</p><p>JAVA
import com.github.jitwxs.sample.ds.config.IDSTaskInfo;
import lombok.Builder;
import lombok.Data;</p><p>@Data
@Builder
public class SchedulerTestTaskInfo implements IDSTaskInfo {
private long id;</p><pre><code>private String cron;

private boolean isValid;

private String reference;

@Override
public boolean isChange(IDSTaskInfo oldTaskInfo) {
    if(oldTaskInfo instanceof SchedulerTestTaskInfo) {
        final SchedulerTestTaskInfo obj = (SchedulerTestTaskInfo) oldTaskInfo;
        return !this.cron.equals(obj.cron) || this.isValid != obj.isValid || !this.reference.equals(obj.getReference());
    } else {
        throw new IllegalArgumentException(&quot;Not Support SchedulerTestTaskInfo type&quot;);
    }
}
</code></pre><p>}
3.3 实现 AbstractDSHandler
有几个需要关注的：</p><p>（1）listTaskInfo() 返回值我使用了 volatile 变量，便于我修改它，模拟任务信息数据的改变。</p><p>（2）doProcess() 方法中，读取到 reference 后，使用反射进行调用，模拟定时任务的执行。</p><p>（3）额外实现了 ApplicationListener 接口，当服务启动后，每隔一段时间修改下任务信息，模拟业务中调整配置。</p><p>服务启动后，foo() 定时任务将每 10s 执行一次。
10s 后，将 foo() 定时任务执行周期从每 10s 执行调整为 1s 执行。
10s 后，关闭 foo() 定时任务执行。
10s 后，开启 foo() 定时任务执行。
JAVA
import com.github.jitwxs.sample.ds.config.AbstractDSHandler;
import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;</p><p>import java.lang.reflect.Method;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.LockSupport;</p><p>/**</p><ul><li><p>@author jitwxs</p></li><li><p>@date 2021年03月27日 21:54
*/
@Component
public class SchedulerTestDSHandler extends AbstractDSHandler<schedulertesttaskinfo> implements ApplicationListener {
public volatile List<schedulertesttaskinfo> taskInfoList = Collections.singletonList(
SchedulerTestTaskInfo.builder()
.id(1)
.cron(&ldquo;0/10 * * * * ? &ldquo;)
.isValid(true)
.reference(&ldquo;com.github.jitwxs.sample.ds.test.SchedulerTest#foo&rdquo;)
.build()
);</p><p>@Override
protected List<schedulertesttaskinfo> listTaskInfo() {
return taskInfoList;
}</p><p>@Override
protected void doProcess(SchedulerTestTaskInfo taskInfo) throws Throwable {
final String reference = taskInfo.getReference();
final String[] split = reference.split(&rdquo;#&rdquo;);
if(split.length != 2) {
return;
}</p><pre><code>try {
    final Class&lt;?&gt; clazz = Class.forName(split[0]);
    final Method method = clazz.getMethod(split[1]);
    method.invoke(clazz.newInstance());
} catch (Exception e) {
    e.printStackTrace();
}
</code></pre><p>}</p><p>@Override
public void onApplicationEvent(ApplicationEvent applicationEvent) {
Executors.newScheduledThreadPool(1).scheduleAtFixedRate(() -> {
LockSupport.parkNanos(TimeUnit.SECONDS.toNanos(10));</p><pre><code>     // setting 1 seconds execute
     taskInfoList = Collections.singletonList(
             SchedulerTestTaskInfo.builder()
                     .id(1)
                     .cron(&quot;0/1 * * * * ? &quot;)
                     .isValid(true)
                     .reference(&quot;com.github.jitwxs.sample.ds.test.SchedulerTest#foo&quot;)
                     .build()
     );

     LockSupport.parkNanos(TimeUnit.SECONDS.toNanos(10));

     // setting not valid
     taskInfoList = Collections.singletonList(
             SchedulerTestTaskInfo.builder()
                     .id(1)
                     .cron(&quot;0/1 * * * * ? &quot;)
                     .isValid(false)
                     .reference(&quot;com.github.jitwxs.sample.ds.test.SchedulerTest#foo&quot;)
                     .build()
     );

     LockSupport.parkNanos(TimeUnit.SECONDS.toNanos(10));

     // setting valid
     taskInfoList = Collections.singletonList(
             SchedulerTestTaskInfo.builder()
                     .id(1)
                     .cron(&quot;0/1 * * * * ? &quot;)
                     .isValid(true)
                     .reference(&quot;com.github.jitwxs.sample.ds.test.SchedulerTest#foo&quot;)
                     .build()
     );
 }, 12, 86400, TimeUnit.SECONDS);
</code></pre><p>}
}
3.4 运行程序
整个应用包结构如下：</p></li></ul><p>包结构</p><p>运行程序后，在控制台可以观测到如下输出：</p><p>运行结果</p><p>四、后记
以上完成了动态定时任务的介绍，你能够根据本篇文章，实现以下需求吗：</p><p>本文基于 cron 表达式实现了频率控制，你能改用 fixedDelay 或 fixedRate 实现吗？
基于数据库/配置文件/配置中心，实现对服务中定时任务的动态频率调整和任务的启停。
开发一个数据表历史数据清理功能，能够动态配置要清理的表、清理的规则、清理的周期。
开发一个数据表异常数据告警功能，能够动态配置要扫描的表、告警的规则、扫描的周期。</p><div class=post-meta></hr>注：本作品采用<a rel=license target=view_window href=http://creativecommons.org/licenses/by-nc-sa/4.0/> 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议 </a>进行许可。</div></div><footer class=post-footer><ul class=post-tags><li><a href=https://swimminghao1.github.io/tags/java/>🏷 java</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Spring SchedulingConfigurer实现动态定时任务(修改) on twitter" href="https://twitter.com/intent/tweet/?text=Spring%20SchedulingConfigurer%e5%ae%9e%e7%8e%b0%e5%8a%a8%e6%80%81%e5%ae%9a%e6%97%b6%e4%bb%bb%e5%8a%a1%28%e4%bf%ae%e6%94%b9%29&url=https%3a%2f%2fswimminghao1.github.io%2fpost%2f02%25E4%25B8%25AA%25E4%25BA%25BA%25E5%25AD%25A6%25E4%25B9%25A0%2f06_02_java%25E9%259D%25A2%25E8%25AF%2595%2fspring-schedulingconfigurer-%25E5%25AE%259E%25E7%258E%25B0%25E5%258A%25A8%25E6%2580%2581%25E5%25AE%259A%25E6%2597%25B6%25E4%25BB%25BB%25E5%258A%25A1%2f&hashtags=java"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Spring SchedulingConfigurer实现动态定时任务(修改) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fswimminghao1.github.io%2fpost%2f02%25E4%25B8%25AA%25E4%25BA%25BA%25E5%25AD%25A6%25E4%25B9%25A0%2f06_02_java%25E9%259D%25A2%25E8%25AF%2595%2fspring-schedulingconfigurer-%25E5%25AE%259E%25E7%258E%25B0%25E5%258A%25A8%25E6%2580%2581%25E5%25AE%259A%25E6%2597%25B6%25E4%25BB%25BB%25E5%258A%25A1%2f&title=Spring%20SchedulingConfigurer%e5%ae%9e%e7%8e%b0%e5%8a%a8%e6%80%81%e5%ae%9a%e6%97%b6%e4%bb%bb%e5%8a%a1%28%e4%bf%ae%e6%94%b9%29&summary=Spring%20SchedulingConfigurer%e5%ae%9e%e7%8e%b0%e5%8a%a8%e6%80%81%e5%ae%9a%e6%97%b6%e4%bb%bb%e5%8a%a1%28%e4%bf%ae%e6%94%b9%29&source=https%3a%2f%2fswimminghao1.github.io%2fpost%2f02%25E4%25B8%25AA%25E4%25BA%25BA%25E5%25AD%25A6%25E4%25B9%25A0%2f06_02_java%25E9%259D%25A2%25E8%25AF%2595%2fspring-schedulingconfigurer-%25E5%25AE%259E%25E7%258E%25B0%25E5%258A%25A8%25E6%2580%2581%25E5%25AE%259A%25E6%2597%25B6%25E4%25BB%25BB%25E5%258A%25A1%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Spring SchedulingConfigurer实现动态定时任务(修改) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fswimminghao1.github.io%2fpost%2f02%25E4%25B8%25AA%25E4%25BA%25BA%25E5%25AD%25A6%25E4%25B9%25A0%2f06_02_java%25E9%259D%25A2%25E8%25AF%2595%2fspring-schedulingconfigurer-%25E5%25AE%259E%25E7%258E%25B0%25E5%258A%25A8%25E6%2580%2581%25E5%25AE%259A%25E6%2597%25B6%25E4%25BB%25BB%25E5%258A%25A1%2f&title=Spring%20SchedulingConfigurer%e5%ae%9e%e7%8e%b0%e5%8a%a8%e6%80%81%e5%ae%9a%e6%97%b6%e4%bb%bb%e5%8a%a1%28%e4%bf%ae%e6%94%b9%29"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Spring SchedulingConfigurer实现动态定时任务(修改) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fswimminghao1.github.io%2fpost%2f02%25E4%25B8%25AA%25E4%25BA%25BA%25E5%25AD%25A6%25E4%25B9%25A0%2f06_02_java%25E9%259D%25A2%25E8%25AF%2595%2fspring-schedulingconfigurer-%25E5%25AE%259E%25E7%258E%25B0%25E5%258A%25A8%25E6%2580%2581%25E5%25AE%259A%25E6%2597%25B6%25E4%25BB%25BB%25E5%258A%25A1%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Spring SchedulingConfigurer实现动态定时任务(修改) on whatsapp" href="https://api.whatsapp.com/send?text=Spring%20SchedulingConfigurer%e5%ae%9e%e7%8e%b0%e5%8a%a8%e6%80%81%e5%ae%9a%e6%97%b6%e4%bb%bb%e5%8a%a1%28%e4%bf%ae%e6%94%b9%29%20-%20https%3a%2f%2fswimminghao1.github.io%2fpost%2f02%25E4%25B8%25AA%25E4%25BA%25BA%25E5%25AD%25A6%25E4%25B9%25A0%2f06_02_java%25E9%259D%25A2%25E8%25AF%2595%2fspring-schedulingconfigurer-%25E5%25AE%259E%25E7%258E%25B0%25E5%258A%25A8%25E6%2580%2581%25E5%25AE%259A%25E6%2597%25B6%25E4%25BB%25BB%25E5%258A%25A1%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Spring SchedulingConfigurer实现动态定时任务(修改) on telegram" href="https://telegram.me/share/url?text=Spring%20SchedulingConfigurer%e5%ae%9e%e7%8e%b0%e5%8a%a8%e6%80%81%e5%ae%9a%e6%97%b6%e4%bb%bb%e5%8a%a1%28%e4%bf%ae%e6%94%b9%29&url=https%3a%2f%2fswimminghao1.github.io%2fpost%2f02%25E4%25B8%25AA%25E4%25BA%25BA%25E5%25AD%25A6%25E4%25B9%25A0%2f06_02_java%25E9%259D%25A2%25E8%25AF%2595%2fspring-schedulingconfigurer-%25E5%25AE%259E%25E7%258E%25B0%25E5%258A%25A8%25E6%2580%2581%25E5%25AE%259A%25E6%2597%25B6%25E4%25BB%25BB%25E5%258A%25A1%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div><nav class=paginav><a class=prev href=https://swimminghao1.github.io/post/02%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/09_01_shell/shell%E8%84%9A%E6%9C%AC/linux-shell%E7%9F%A5%E8%AF%86%E7%82%B9/><span class=title>« 上一页</span><br><span>shell知识点</span></a>
<a class=next href=https://swimminghao1.github.io/post/02%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/09_01_shell/shell%E8%84%9A%E6%9C%AC/%E6%8A%A5%E5%91%8A%E5%88%86%E7%B1%BBbash/><span class=title>下一页 »</span><br><span>报告分类bash</span></a></nav></footer></article></main><footer class=footer><span>Copyright &copy; 2023 • <a href=https://swimminghao1.github.io/>swimminghao</a></span><div><span><a href=/about/>关于</a>
• <a href=/disclaimer/>免责声明</a>
• <a href=/sitemap.xml target=view_window>站点地图</a>
• <a href=https://www.foreverblog.cn/go.html target=view_window>虫洞</a>
• PV <span id=busuanzi_value_site_pv><i class="fa fa-spinner fa-spin"></i></span></span></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><meta name=”apple-mobile-web-app-capable” content="”yes”"><script>"serviceWorker"in navigator&&window.addEventListener("load",()=>{navigator.serviceWorker.register("/service-worker.js")})</script></body></html>